import { NextRequest, NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";

const SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const SERVICE_ROLE = process.env.SUPABASE_SERVICE_ROLE_KEY!;
const IMPORT_SHARED_SECRET = process.env.IMPORT_SHARED_SECRET!;
const DEV_USER_ID = process.env.DEV_USER_ID!; // fallback owner

function ok<T>(data: T, status = 200) {
  return NextResponse.json(data as any, { status });
}
function err(message: string, status = 400, extra: any = {}) {
  return NextResponse.json({ error: message, ...extra }, { status });
}

function checkAuth(req: NextRequest) {
  const h = req.headers;
  const xs = h.get("x-shared-secret");
  const auth = h.get("authorization") || "";
  const bearer = auth.toLowerCase().startsWith("bearer ") ? auth.slice(7) : null;
  return xs === IMPORT_SHARED_SECRET || bearer === IMPORT_SHARED_SECRET;
}

type ImportPayload = {
  requestId?: string;
  userEmail?: string;
  file?: {
    md5: string;
    name: string;
    storage_path?: string;
    original_name?: string;
    size_bytes?: number;
    course_id?: string | null;
    kind?: string; // matches file_kind enum values if you use them
  };
  ocr_texts?: Array<{ text: string; page?: number; engine?: string }>;
  notes?: Array<{ title?: string; content: string }>;
  flashcards?: Array<{ front?: string; back?: string; question?: string; answer?: string }>;
  quiz?: {
    title?: string;
    questions: Array<{
      prompt: string;
      answers?: Array<{ label: string; is_correct?: boolean }>;
    }>;
  } | null;
};

export async function GET() {
  return ok({ status: "ok", route: "/api/import" });
}

export async function POST(req: NextRequest) {
  try {
    if (!checkAuth(req)) return err("Unauthorized", 401);

    const supabase = createClient(SUPABASE_URL, SERVICE_ROLE, { auth: { persistSession: false } });
    const payload = (await req.json()) as ImportPayload;
    const requestId = payload.requestId || `imp_${crypto.randomUUID()}`;

    // Resolve owner_id by email -> profiles.email
    let owner_id = DEV_USER_ID;
    if (payload.userEmail) {
      const { data: prof, error: pe } = await supabase
        .from("profiles")
        .select("id")
        .eq("email", payload.userEmail)
        .maybeSingle();
      if (pe) console.warn("profiles lookup error:", pe);
      if (prof?.id) owner_id = prof.id;
    }

    // Queue job
    const { data: job0, error: j0e } = await supabase
      .from("jobs")
      .insert({
        owner_id,
        kind: "import",
        status: "queued",
        payload,
        queued_at: new Date().toISOString()
      })
      .select("id")
      .single();
    if (j0e) return err("Failed to queue job", 500, { requestId, detail: j0e.message });

    const job_id = job0.id;

    // Mark started
    await supabase
      .from("jobs")
      .update({ status: "started", started_at: new Date().toISOString() })
      .eq("id", job_id);

    // === Upsert file (idempotent via md5) ===
    let file_id: string | null = null;

    if (payload.file?.md5) {
      // Try get existing by md5
      const { data: existing, error: ge } = await supabase
        .from("files")
        .select("id")
        .eq("md5", payload.file.md5)
        .maybeSingle();

      if (ge) throw new Error(`files lookup failed: ${ge.message}`);

      if (existing?.id) {
        file_id = existing.id;
      } else {
        const { data: nf, error: nfe } = await supabase
          .from("files")
          .insert({
            owner_id,
            course_id: payload.file.course_id ?? null,
            storage_path: payload.file.storage_path ?? "",
            original_name: payload.file.original_name ?? payload.file.name,
            kind: payload.file.kind ?? "unknown",
            md5_hex: payload.file.md5,
            md5: payload.file.md5,        // you already have UNIQUE on md5
            size_bytes: payload.file.size_bytes ?? null,
            name: payload.file.name
          })
          .select("id")
          .single();
        if (nfe) throw new Error(`files insert failed: ${nfe.message}`);
        file_id = nf!.id;
      }
    }

    // === OCR texts ===
    if (file_id && payload.ocr_texts?.length) {
      const rows = payload.ocr_texts.map((t, i) => ({
        file_id,
        owner_id,
        file_md5: payload.file?.md5 ?? null,
        text: t.text,
        engine: t.engine ?? "google_docs_ocr",
        page: t.page ?? i + 1
      }));
      const { error: oe } = await supabase.from("ocr_texts").insert(rows);
      if (oe) throw new Error(`ocr_texts insert failed: ${oe.message}`);
    }

    // === Notes ===
    if (payload.notes?.length) {
      const rows = payload.notes.map(n => ({
        owner_id,
        course_id: payload.file?.course_id ?? null,
        file_id,
        title: n.title ?? null,
        content: n.content
      }));
      const { error: ne } = await supabase.from("notes").insert(rows);
      if (ne) throw new Error(`notes insert failed: ${ne.message}`);
    }

    // === Flashcards ===
    if (payload.flashcards?.length) {
      const rows = payload.flashcards.map(f => ({
        owner_id,
        course_id: payload.file?.course_id ?? null,
        file_id,
        front: f.front ?? f.question ?? "",
        back:  f.back  ?? f.answer  ?? ""
      }));
      const { error: fe } = await supabase.from("flashcards").insert(rows);
      if (fe) throw new Error(`flashcards insert failed: ${fe.message}`);
    }

    // === Quiz (optional) ===
    if (payload.quiz?.questions?.length) {
      const { data: qz, error: qze } = await supabase
        .from("quizzes")
        .insert({
          owner_id,
          course_id: payload.file?.course_id ?? null,
          title: payload.quiz.title ?? null
        })
        .select("id")
        .single();
      if (qze) throw new Error(`quiz insert failed: ${qze.message}`);

      const quiz_id = qz!.id;

      // Insert questions
      const qRows = payload.quiz.questions.map(q => ({
        quiz_id,
        prompt: q.prompt
      }));
      const { data: qIns, error: qie } = await supabase
        .from("quiz_questions")
        .insert(qRows)
        .select("id");
      if (qie) throw new Error(`quiz_questions insert failed: ${qie.message}`);

      // If answers provided, insert them per index
      if (payload.quiz.questions.some(q => q.answers?.length)) {
        const aRows: any[] = [];
        payload.quiz.questions.forEach((q, idx) => {
          const qId = qIns[idx].id;
          q.answers?.forEach(a => {
            aRows.push({
              question_id: qId,
              label: a.label,
              is_correct: !!a.is_correct,
              owner_id   : owner_id
            });
          });
        });
        if (aRows.length) {
          const { error: aie } = await supabase.from("quiz_answers").insert(aRows);
          if (aie) throw new Error(`quiz_answers insert failed: ${aie.message}`);
        }
      }
    }

    // Finish job
    await supabase
      .from("jobs")
      .update({
        status: "finished",
        finished_at: new Date().toISOString(),
        result: { ok: true, requestId, file_id }
      })
      .eq("id", job_id);

    return ok({ ok: true, requestId, file_id });
  } catch (e: any) {
    try {
      // best-effort: mark job failed if we created it (ignore errors)
      // we can't read job_id here if an early failure happened; that's fine
    } catch {}
    return err("Import failed", 500, { detail: e?.message });
  }
}
