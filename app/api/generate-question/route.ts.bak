import { NextResponse } from "next/server";
import { cookies as nextCookies } from "next/headers";
import { createServerClient } from "@supabase/ssr";
import { withAutoRanking } from "@/lib/retrieval/withAutoRanking";
import { askLLM } from "@/lib/ai/ask";

/** Debug-flags */
const DEBUG_RETRIEVAL = process.env.DEBUG_RETRIEVAL === "1";
const seenRetrievalWarns = new Set<string>();

/** Dev-only user bypass via x-shared-secret */
async function getDevUserId(req: Request): Promise<string | null> {
  if (process.env.NODE_ENV === "production") return null;
  try {
    const secret = req.headers.get("x-shared-secret") ?? req.headers.get("x-dev-secret");
    if (secret && secret === process.env.IMPORT_SHARED_SECRET) {
      return process.env.DEV_USER_ID ?? null;
    }
  } catch {}
  return null;
}

/** Tjek checkbox/parametre fra body */
function wantsReferencesFromBody(body: any) {
  const vals = [
    body?.includeBackground,
    body?.includeReferences,
    body?.withReferences,
    body?.withBackground,
  ];
  return vals.some((v) =>
    typeof v === "string"
      ? v.toLowerCase() === "true" || v === "on" || v === "1"
      : v === true
  );
}

async function getColumns(supabase: any, table: string): Promise<string[]> {
  try {
    const { data, error } = await supabase.from(table).select("*").limit(1);
    if (error) {
      if (DEBUG_RETRIEVAL && !seenRetrievalWarns.has(error.message)) {
        console.warn(`[columns] ${table}: ${error.message}`);
        seenRetrievalWarns.add(error.message);
      }
      return [];
    }
    const row = Array.isArray(data) ? data[0] : data;
    if (!row) return [];
    return Object.keys(row);
  } catch (e: any) {
    const msg = `[columns] ${table}: ${e?.message ?? e}`;
    if (DEBUG_RETRIEVAL && !seenRetrievalWarns.has(msg)) {
      console.warn(msg);
      seenRetrievalWarns.add(msg);
    }
    return [];
  }
}

async function safe(q: any) {
  try {
    const { data, error } = await q;
    if (error) {
      if (DEBUG_RETRIEVAL && !seenRetrievalWarns.has(error.message)) {
        console.warn(`[retrieval] error: ${error.message}`);
        seenRetrievalWarns.add(error.message);
      }
      return [];
    }
    return data ?? [];
  } catch (e: any) {
    const msg = `[retrieval] unexpected: ${e?.message ?? e}`;
    if (DEBUG_RETRIEVAL && !seenRetrievalWarns.has(msg)) {
      console.warn(msg);
      seenRetrievalWarns.add(msg);
    }
    return [];
  }
}

async function getChunks(
  supabase: any,
  opts: { ownerId: string; studySetId?: string | null; includeBackground?: boolean; topK?: number }
) {
  const { ownerId, studySetId, includeBackground = false, topK = 12 } = opts;

  // Brug view hvis det findes; ellers fallback til tabellen
  let table = "doc_chunks_rank_ready";
  let docCols = await getColumns(supabase, table);
  if (docCols.length === 0) {
    table = "doc_chunks";
    docCols = await getColumns(supabase, table);
  }

  const textCandidates = ["text", "content", "chunk", "chunk_text", "raw_text", "body", "page_text", "pageContent"];
  const textKey = textCandidates.find((k) => docCols.includes(k));

  const wantedBase = [
    "id",
    "source_title",
    "source_url",
    "source_type",
    "source_domain",
    "verified_weight",
    "manual_academic_weight",
    "domain_boost_dk",
    "lang_boost_da",
    "language",
    "lang_code",
    "similarity",
  ].filter((k) => docCols.includes(k));

  const selectArr = textKey ? ["id", textKey, ...wantedBase.filter((k) => k !== "id")] : (wantedBase.length ? wantedBase : ["id"]);
  const selectStr = selectArr.join(",");

  let base = supabase.from(table).select(selectStr).limit(topK);
  if (docCols.includes("owner_id")) base = base.eq("owner_id", ownerId);
  if (studySetId && docCols.includes("study_set_id")) base = base.eq("study_set_id", studySetId);
  const userChunks = await safe(base);

  let bgChunks: any[] = [];
  if (includeBackground) {
    let bgQ = supabase.from(table).select(selectStr).limit(Math.max(4, Math.floor(topK / 2)));
    if (docCols.includes("source_type")) bgQ = bgQ.eq("source_type", "verified");
    bgChunks = await safe(bgQ);
  }

  const combined: any[] = [...userChunks, ...bgChunks].slice(0, topK);

  const text = textKey ? combined.map((c) => c?.[textKey] ?? "").join("\n\n---\n\n") : "";

  const citations = combined
    .map((c) => ({ id: c?.id, title: c?.source_title, url: c?.source_url, type: c?.source_type }))
    .filter((x) => x.id);

  const candidates = combined.map((c) => {
    const langFlag =
      (typeof c?.lang_boost_da !== "undefined")
        ? Number(c.lang_boost_da ?? 0)
        : ((String(c?.language ?? c?.lang_code ?? "")).toLowerCase().startsWith("da") ? 10 : 0);

    return {
      id: c?.id,
      text: textKey ? (c?.[textKey] ?? "") : "",
      similarity: Number(c?.similarity ?? 0),
      verified_weight: Number(c?.verified_weight ?? 0),
      manual_academic_weight: Number(c?.manual_academic_weight ?? 0),
      lang_boost_da: Number(langFlag ?? 0),
      domain_boost_dk: Number(c?.domain_boost_dk ?? 0),
    };
  });

  return { text, citations, textKey, candidates };
}

export async function POST(req: Request) {
  const body = await req.json().catch(() => ({} as any));
  const includeBackground: boolean = wantsReferencesFromBody(body);
  const studySetId: string | null = body.studySetId ?? null;

  try {
    // User-scoped supabase (RLS via cookies)
    const cookieStore = await nextCookies();
    const supabase = createServerClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
      {
        cookies: {
          get(name: string) { return cookieStore.get(name)?.value; },
          set() {},
          remove() {},
        },
      }
    );

    const { data: { user }, error: userErr } = await supabase.auth.getUser();
    let userId = (user as any)?.id ?? null;
    if (!userId) {
      const devId = await getDevUserId(req as any);
      if (devId) userId = devId;
    }
    if (userErr || !userId) {
      if (userErr) console.warn("[generate-question] getUser error:", (userErr as any)?.message ?? String(userErr));
      return NextResponse.json({ error: "unauthorized" }, { status: 401 });
    }

    // 1) Hent chunks for brugeren
    const retrieval = await getChunks(supabase, {
      ownerId: userId,
      studySetId,
      includeBackground,
      topK: 12,
    });

    // 2) Auto-rank kontekst (sikker fallback)
    let contextText = retrieval.text ?? "";
    let topCitations: Array<{ title?: string; url?: string; verified?: boolean }> = [];

    try {
      const ranked = await withAutoRanking(supabase, retrieval as any, 20, userId);
      if (Array.isArray(ranked) && ranked.length > 0) {
        contextText = ranked
          .map((r: any) => (typeof r.text === "string" ? r.text : ""))
          .filter(Boolean)
          .join("\n\n---\n\n")
          .slice(0, 12000);

        topCitations = ranked.slice(0, 3).map((r: any) => ({
          title: r.title ?? r.source_title ?? undefined,
          url: r.url ?? r.source_url ?? undefined,
          verified: !!r.verified,
        }));
      }
    } catch (err) {
      console.error("withAutoRanking failed:", err);
    }

    // 3) LLM (med pæn fallback hvis slået fra)
    let questionText = "Formulér et spørgsmål baseret på materialet.";
    try {
      const systemPrompt = "Du er en dansk eksaminator. Svar KUN med selve spørgsmålsteksten  ingen forklaringer.";
      const userPrompt = `
Kontekst (udvalg fra materialet):
<<CONTEXT>>
${contextText}
<<END>>

Opgave:
Formulér ét skarpt, kort eksamensspørgsmål på dansk, som kan besvares uden flere delspørgsmål.
Hold det på 12 linjer.
`;
      questionText = await askLLM(systemPrompt, userPrompt);
    } catch {
      questionText = "Formulér hovedpointerne i materialet, og forklar hvorfor kilderne er relevante.";
    }

    // 4) Gate citations/kontekst efter brugerens valg
    const citationsPayload = includeBackground ? topCitations : [];
    const contextPreviewPayload = includeBackground ? (contextText.slice(0, 500)) : "";

    return NextResponse.json(
      {
        ok: true,
        question: { text: questionText },
        questionText,
        citations: citationsPayload,
        contextPreview: contextPreviewPayload,
      },
      { status: 200 }
    );
  } catch {
    return NextResponse.json(
      {
        ok: true,
        question: { text: "Formulér et spørgsmål baseret på materialet." },
        questionText: "Formulér et spørgsmål baseret på materialet.",
        citations: [],
        contextPreview: "",
      },
      { status: 200 }
    );
  }
}
