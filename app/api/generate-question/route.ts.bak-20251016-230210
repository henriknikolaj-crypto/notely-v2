export const runtime = "nodejs";
export const dynamic = "force-dynamic";
import { NextRequest } from "next/server";
// Justér sti hvis din helper ligger andetsteds:
import { supabaseServerRoute } from "@/app/(lib)/supabaseServerRoute";
import OpenAI from "openai";

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

export async function POST(req: NextRequest) {
  try {
    const { supabase, user } = await supabaseServerRoute();
    if (!user) return Response.json({ error: "Unauthorized" }, { status: 401 });

    const body = await req.json().catch(() => ({} as any));
    const studySetId = body?.studySetId ?? null;

    // Hent noget relevant kontekst fra brugerens noter
    const { data: chunks, error } = await supabase
      .from("doc_chunks")
      .select("id, content")
      .eq("owner_id", user.id)
      .limit(8);

    if (error) return Response.json({ error: error.message }, { status: 500 });
    if (!chunks || chunks.length === 0) {
      return Response.json({ error: "Ingen materiale fundet. Upload noter først.", code: "NO_CHUNKS" }, { status: 400 });
    }

    const context = chunks.map(c => (c?.content ?? "").trim()).filter(Boolean).join("\n\n---\n\n");

    const sys = "Du er en dansk eksaminator. Du skriver KORTE, klare eksamensspørgsmål baseret på brugerens materiale.";
    const usr = `Kontekst (uddrag fra brugerens egne noter):

${context}

Opgave: Skriv ét specifikt eksamensspørgsmål på dansk, maks 2 sætninger.
Svar KUN med selve spørgsmålet.`;

    const completion = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        { role: "system", content: sys },
        { role: "user", content: usr },
      ],
      temperature: 0.4,
      max_tokens: 120,
    });

    const question = completion.choices?.[0]?.message?.content?.trim();
    if (!question) return Response.json({ error: "Model gav ikke noget spørgsmål" }, { status: 502 });

    // Opret exam_session (status: generated)
    const insertRow: any = {
      owner_id: user.id,
      question,
      status: "generated",
      model: "gpt-4o-mini",
    };
    if (studySetId) insertRow.study_set_id = studySetId; // bruges kun hvis kolonnen findes

    const { data: ins, error: insErr } = await supabase
      .from("exam_sessions")
      .insert(insertRow)
      .select("id")
      .single();

    if (insErr) return Response.json({ error: insErr.message }, { status: 500 });

    // Best-effort logging
    try {
      await supabase.from("jobs").insert({
        type: "generate_question",
        status: "succeeded",
        owner_id: user.id,
        meta: { chunk_count: chunks.length, session_id: ins?.id ?? null, question_len: question.length },
      });
    } catch {}

    return Response.json({
      ok: true,
      sessionId: ins?.id ?? null,
      question,
      chunkCount: chunks.length,
      usedChars: context.length,
    });
  } catch (e: any) {
    return Response.json({ error: e?.message ?? "Ukendt fejl" }, { status: 500 });
  }
}



