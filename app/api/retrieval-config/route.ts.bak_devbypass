import { NextResponse } from "next/server";
import { cookies as nextCookies } from "next/headers";
import { createServerClient } from "@supabase/ssr";

// Fallbacks hvis brugeren ikke har sat noget selv:
const DEF_ALPHA    = Number(process.env.RETRIEVAL_DEFAULT_ALPHA   ?? 0.25);
const DEF_BETA     = Number(process.env.RETRIEVAL_DEFAULT_BETA    ?? 0.15);
const DEF_M_LANG   = Number(process.env.RETRIEVAL_DEFAULT_M_LANG  ?? 0.10);
const DEF_M_DOMAIN = Number(process.env.RETRIEVAL_DEFAULT_M_DOMAIN?? 0.15);

type Row = {
  owner_id: string;
  alpha: number;
  beta: number;
  m_lang: number;
  m_domain: number;
  updated_at?: string | null;
};

function clamp01(n: any) {
  const x = Number(n);
  if (!Number.isFinite(x)) return null;
  return Math.max(0, Math.min(1, x));
}

async function getClient() {
  const cookieStore = await nextCookies();
  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) { return cookieStore.get(name)?.value; },
        set() {}, remove() {},
      },
    }
  );
  return supabase;
}

export async function GET() {
  try {
    const supabase = await getClient();
    const { data: { user }, error: userErr } = await supabase.auth.getUser();
    if (userErr || !user) return NextResponse.json({ error: "unauthorized" }, { status: 401 });

    const { data, error } = await supabase
      .from("retrieval_config")
      .select("owner_id, alpha, beta, m_lang, m_domain, updated_at")
      .eq("owner_id", user.id)
      .maybeSingle();

    const payload: Row = data ?? {
      owner_id: user.id,
      alpha: DEF_ALPHA,
      beta: DEF_BETA,
      m_lang: DEF_M_LANG,
      m_domain: DEF_M_DOMAIN,
      updated_at: null,
    };

    return NextResponse.json(payload);
  } catch (e: any) {
    console.error("[retrieval-config][GET] fatal:", e?.stack || e?.message || e);
    return NextResponse.json({ error: "server error" }, { status: 500 });
  }
}

export async function POST(req: Request) {
  try {
    const supabase = await getClient();
    const { data: { user }, error: userErr } = await supabase.auth.getUser();
    if (userErr || !user) return NextResponse.json({ error: "unauthorized" }, { status: 401 });

    const body = await req.json().catch(() => ({} as any));

    // Læs evt. eksisterende værdier (delvise updates tilladt)
    const { data: current } = await supabase
      .from("retrieval_config")
      .select("alpha, beta, m_lang, m_domain")
      .eq("owner_id", user.id)
      .maybeSingle();

    const alpha    = body.alpha   != null ? clamp01(body.alpha)   : (current?.alpha    ?? DEF_ALPHA);
    const beta     = body.beta    != null ? clamp01(body.beta)    : (current?.beta     ?? DEF_BETA);
    const m_lang   = body.mLang   != null ? clamp01(body.mLang)   : (current?.m_lang   ?? DEF_M_LANG);
    const m_domain = body.mDomain != null ? clamp01(body.mDomain) : (current?.m_domain ?? DEF_M_DOMAIN);

    if ([alpha, beta, m_lang, m_domain].some(v => v === null)) {
      return NextResponse.json({ error: "alpha/beta/mLang/mDomain must be numbers in [0..1]" }, { status: 400 });
    }

    const upsert: Row = {
      owner_id: user.id,
      alpha: alpha as number,
      beta: beta as number,
      m_lang: m_lang as number,
      m_domain: m_domain as number,
    };

    const { data, error } = await supabase
      .from("retrieval_config")
      .upsert(upsert, { onConflict: "owner_id" })
      .select("owner_id, alpha, beta, m_lang, m_domain, updated_at")
      .single();

    if (error) {
      console.error("[retrieval-config][POST] upsert error:", error.message);
      return NextResponse.json({ error: error.message }, { status: 500 });
    }

    return NextResponse.json(data);
  } catch (e: any) {
    console.error("[retrieval-config][POST] fatal:", e?.stack || e?.message || e);
    return NextResponse.json({ error: "server error" }, { status: 500 });
  }
}
