import { supabaseServerRoute } from "@/lib/supabase/server-route";
import { withAutoRanking } from "@/lib/retrieval/withAutoRanking";

import { applyAcademicDanishScoring } from "@/lib/retrieval/score";
import { NextResponse } from "next/server";
import { cookies as nextCookies } from "next/headers";
import { createServerClient } from "@supabase/ssr";

/** Ekstra retrieval-logs pr. .env.local -> DEBUG_RETRIEVAL=1 */
const DEBUG_RETRIEVAL = process.env.DEBUG_RETRIEVAL === "1";
const seenRetrievalWarns = new Set<string>();

function wantsReferencesFromBody(body: any) {
  const vals = [
    body?.includeBackground,
    body?.includeReferences,
    body?.withReferences,
    body?.withBackground,
  ];
  return vals.some((v) =>
    typeof v === "string"
      ? v.toLowerCase() === "true" || v === "on" || v === "1"
      : v === true
  );
}

async function getColumns(supabase: any, table: string): Promise<string[]> {
  try {
    const { data, error } = await supabase.from(table).select("*").limit(1);
    if (error) {
      if (DEBUG_RETRIEVAL && !seenRetrievalWarns.has(error.message)) {
        console.warn(`[columns] ${table}: ${error.message}`);
        seenRetrievalWarns.add(error.message);
      }
      return [];
    }
    const row = Array.isArray(data) ? data[0] : data;
    if (!row) return [];
    return Object.keys(row);
  } catch (e: any) {
    const msg = `[columns] ${table}: ${e?.message ?? e}`;
    if (DEBUG_RETRIEVAL && !seenRetrievalWarns.has(msg)) {
      console.warn(msg);
      seenRetrievalWarns.add(msg);
    }
    return [];
  }
}

async function safe(q: any) {
  try {
    const { data, error } = await q;
    if (error) {
      if (DEBUG_RETRIEVAL && !seenRetrievalWarns.has(error.message)) {
        console.warn(`[retrieval] error: ${error.message}`);
        seenRetrievalWarns.add(error.message);
      }
      return [];
    }
    return data ?? [];
  } catch (e: any) {
    const msg = `[retrieval] unexpected: ${e?.message ?? e}`;
    if (DEBUG_RETRIEVAL && !seenRetrievalWarns.has(msg)) {
      console.warn(msg);
      seenRetrievalWarns.add(msg);
    }
    return [];
  }
}

async function getChunks(
  supabase: any,
  opts: { ownerId: string; studySetId?: string | null; includeBackground?: boolean; topK?: number }
) {
  const { ownerId, studySetId, includeBackground = false, topK = 12 } = opts;

  const docCols = await getColumns(supabase, "doc_chunks");
  const textCandidates = ["text", "content", "chunk", "chunk_text", "raw_text", "body", "page_text", "pageContent"];
  const textKey = textCandidates.find((k) => docCols.includes(k));

  const wantedBase = ["id", "source_title", "source_url", "source_type"];
  const wanted = wantedBase.filter((k) => docCols.includes(k));

  const selectArr = textKey ? ["id", textKey, ...wanted.filter((k) => k !== "id")] : wanted.length ? wanted : ["id"];
  const selectStr = selectArr.join(",");

  let base = supabase.from("doc_chunks").select(selectStr).limit(topK);
  if (docCols.includes("owner_id")) base = base.eq("owner_id", ownerId);
  if (studySetId && docCols.includes("study_set_id")) base = base.eq("study_set_id", studySetId);
  const userChunks = await safe(base);

  let bgChunks: any[] = [];
  if (includeBackground) {
    let bgQ = supabase.from("doc_chunks").select(selectStr).limit(Math.max(4, Math.floor(topK / 2)));
    if (docCols.includes("source_type")) bgQ = bgQ.eq("source_type", "verified");
    bgChunks = await safe(bgQ);
  }

  const combined: any[] = [...userChunks, ...bgChunks].slice(0, topK);
  const text = textKey ? combined.map((c) => c?.[textKey] ?? "").join("\n\n---\n\n") : "";
  const citations = combined
    .map((c) => ({ id: c?.id, title: c?.source_title, url: c?.source_url, type: c?.source_type }))
    .filter((x) => x.id);

  return { text, citations, textKey };
}

async function callModelWithContext(input: { question: string; answer: string; contextText: string }) {
  return {
    score: 20,
    feedback: input.contextText
      ? "Evaluering gennemført. Der blev fundet baggrundstekst."
      : "Evaluering gennemført (uden baggrund).",
  };
}
export async function POST(req: Request) {
  // [AUTORANK-START]
  // Auto-rangering (akademisk > sprog)  SAFE
  let contextText: string = "";
  // @ts-ignore  retrieval findes ikke nødvendigvis i alle endpoints
  const maybeRetrieval: any = (typeof retrieval !== "undefined") ? (retrieval as any) : null;
  if (maybeRetrieval) {
    const supabase = await supabaseServerRoute();
    const _auto = await withAutoRanking(supabase, maybeRetrieval, 20);
    contextText = (typeof _auto?.rankedText === "string" && _auto.rankedText.trim().length > 0)
      ? _auto.rankedText
      : (maybeRetrieval?.text ?? "");
  }
  // [AUTORANK-END]
  
  let _autoRanked: any = null;
  // @ts-ignore  retrieval findes ikke nødvendigvis i alle endpoints
  if (typeof retrieval !== "undefined" && retrieval) {
    const supabase = await supabaseServerRoute();
    // @ts-ignore
    _autoRanked = await withAutoRanking(supabase, retrieval, 20);
    // @ts-ignore
    contextText = (typeof _autoRanked?.rankedText === "string" && _autoRanked.rankedText.trim().length > 0)
      ? _autoRanked.rankedText
      : (retrieval?.text ?? "");
  }
  // Auto-mode: altid blid præference for dansk
  const preferDanish = true;

  try {
    const includeBackground: boolean = wantsReferencesFromBody(body);
    const studySetId: string | null = body.studySetId ?? null;
    const question: string = String(body.question ?? "");
    const answer: string = String(body.answer ?? "");

    const cookieStore = await nextCookies();
    const supabase = createServerClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
      {
        cookies: {
          get(name: string) { return cookieStore.get(name)?.value; },
          set() {},
          remove() {},
        },
      }
    );

    const { data: { user }, error: userErr } = await supabase.auth.getUser();
    if (userErr) {
      console.warn("[evaluate] getUser error:", (userErr as any)?.message ?? String(userErr));
      return NextResponse.json({ error: "unauthorized" }, { status: 401 });
    }
    if (!user) {
      return NextResponse.json({ error: "unauthorized" }, { status: 401 });
    }

    const retrieval = await getChunks(supabase, {
      ownerId: user.id,
      studySetId,
      includeBackground,
      topK: 12,
    });
  
let _autoRanked: any = null;

// @ts-ignore  retrieval findes ikke nødvendigvis i alle endpoints (fx generate-question)
if (typeof retrieval !== "undefined" && retrieval) {
  // @ts-ignore
  _autoRanked = await withAutoRanking(supabase, retrieval, 20);
  if (typeof _autoRanked?.rankedText === "string" && _autoRanked.rankedText.trim().length > 0) {
    contextText = _autoRanked.rankedText;
  } else {
    // @ts-ignore
    contextText = retrieval?.text ?? "";
  }
} else {
  // ingen retrieval i denne route -> behold contextText = "" (eller sæt din egen fallback her)
}
let _autoRanked: any = null;

// @ts-ignore  retrieval findes ikke nødvendigvis i alle endpoints (fx generate-question)
if (typeof retrieval !== "undefined" && retrieval) {
  // @ts-ignore
  _autoRanked = await withAutoRanking(supabase, retrieval, 20);
  if (typeof _autoRanked?.rankedText === "string" && _autoRanked.rankedText.trim().length > 0) {
    contextText = _autoRanked.rankedText;
  } else {
    // @ts-ignore
    contextText = retrieval?.text ?? "";
  }
} else {
  // ingen retrieval i denne route -> behold contextText = "" (eller sæt din egen fallback her)
}

    const hasVerified =
      Array.isArray(retrieval.citations) &&
      retrieval.citations.some((c: any) => (c?.type ?? c?.source_type) === "verified");

    const bgFound = !!includeBackground && (hasVerified || (retrieval.citations?.length ?? 0) > 0);

    const llmAnswer = await callModelWithContext({ question, answer, contextText: contextText });

    const examCols = await getColumns(supabase, "exam_sessions");
    const payload: any = { owner_id: user.id, user_id: user.id };
    if (examCols.includes("question"))  payload.question  = question;
    if (examCols.includes("answer"))    payload.answer    = answer;
    if (examCols.includes("score"))     payload.score     = llmAnswer.score ?? null;
    if (examCols.includes("feedback"))  payload.feedback  = llmAnswer.feedback ?? null;
    if (examCols.includes("model"))     payload.model     = "gpt-4o-mini";

    const metaObj = {
      includeBackground,
      bgRequested: includeBackground,
      studySetId,
      bgFound,
      citations: retrieval.citations,
      textKey: contextTextKey
    };
    if (examCols.includes("meta"))      payload.meta      = metaObj;
    else if (examCols.includes("metadata")) payload.metadata = metaObj;

    const { data, error } = await supabase.from("exam_sessions").insert(payload).select("id").single();
    if (error) {
      console.error("[evaluate] insert error:", error.message, "payload keys:", Object.keys(payload));
      return NextResponse.json({ error: error.message }, { status: 500 });
    }

    return NextResponse.json({
      id: data!.id,
      score: llmAnswer.score,
      feedback: llmAnswer.feedback,
      meta: metaObj
    });
  } catch (e: any) {
    console.error("[evaluate] fatal:", e?.stack || e?.message || e);
    return NextResponse.json({ error: e?.message || "server error" }, { status: 500 });
  }
}











