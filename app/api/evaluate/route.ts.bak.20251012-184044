import { headers, cookies } from "next/headers";
import { createClient } from "@supabase/supabase-js";

type Body = {
  analysis_type: "notes" | "quiz" | "flashcards";
  material: { type: "selection"; ids: string[]; scope: "files" | "folder" | "all" };
  academic_boost?: boolean;
  client_context?: { app_version?: string; ui_locale?: string };
};

function supaWithBearer(token: string) {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    { global: { headers: { Authorization: `Bearer ${token}` } } }
  );
}
function supaService() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
}

export async function POST(req: Request) {
    const supabase = await supabaseServer(); const { data: { user } } = await supabase.auth.getUser(); if(!user) return NextResponse.json({ error: "Unauthorized" }, { status: 401 }); const hdrs = await headers();
  let ownerId: string | null = null;
  let supa = null;

  // 1) Bearer (fra PS scripts)
  const auth = hdrs.get("authorization") || "";
  const token = auth.toLowerCase().startsWith("bearer ") ? auth.slice(7) : "";
  if (token) {
    supa = supaWithBearer(token);
    const { data, error } = await supa.auth.getUser();
    if (error || !data?.user) return new Response("Unauthorized", { status: 401 });
    ownerId = data.user.id;
  }

  // 2) Dev fallback (x-shared-secret + user.id)
  if (!ownerId && hdrs.get("x-shared-secret") === process.env.IMPORT_SHARED_SECRET) {
    const devUser = process.env.user.id;
    if (!devUser) return new Response("Missing user.id", { status: 400 });
    supa = supaService(); // service key til at skrive uden cookies
    ownerId = devUser;
  }

  // 3) Cookie-session (UI)
  if (!ownerId) {
    const cookieStore = await cookies();
    const supaCookie = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
      { cookies: { get: (name: string) => cookieStore.get(name)?.value } }
    );
    const { data, error } = await supaCookie.auth.getUser();
    if (!error && data?.user) {
      supa = supaCookie;
      ownerId = data.user.id;
    }
  }

  if (!ownerId || !supa) return new Response("Unauthorized", { status: 401 });

  // Parse body
  let body: Body;
  try {
    body = (await req.json()) as Body;
  } catch {
    return new Response("Invalid JSON", { status: 400 });
  }

  // Filters / Contextual Intelligence profil
  const filters = {
    profile: body.academic_boost ? "academic_soft" : "default",
    priority: ["user_uploads", "verified_sources", "open_context"],
    weights: { user: 1.0, verified: 0.75, open: 0.35 },
    boosts: { region_hint: "DK/EU" },
    never_exclude: true,
    latent_background: true,
  };

  // Opret job (queued)
  const insert = {
    kind: "evaluate",
    status: "queued",
    owner_id: ownerId,
    analysis_type: body.analysis_type,
    material: body.material,
    filters,
    client_context: body.client_context ?? null,
    tokens_used: null,
    latency_ms: null,
  };

  try {
    const { data, error } = await supa.from("jobs").insert(insert).select("*").single();
    if (error) return Response.json({ ok: false, error: error.message }, { status: 400 });
    return Response.json({ ok: true, job: { id: data.id, status: data.status, kind: data.kind, created_at: data.created_at } });
  } catch (e: any) {
    return Response.json({ ok: false, error: e?.message ?? "unknown" }, { status: 400 });
  }
}

