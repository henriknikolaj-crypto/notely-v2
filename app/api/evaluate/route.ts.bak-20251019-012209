import { NextResponse } from "next/server";
import { cookies as nextCookies } from "next/headers";
import { createServerClient } from "@supabase/ssr";

/** Ekstra retrieval-logs pr. .env.local -> DEBUG_RETRIEVAL=1 */
const DEBUG_RETRIEVAL = process.env.DEBUG_RETRIEVAL === "1";
const seenRetrievalWarns = new Set<string>();

/* --------- helpers --------- */

function wantsReferencesFromBody(body: any) {
  const vals = [
    body?.includeBackground,
    body?.includeReferences,
    body?.withReferences,
    body?.withBackground,
  ];
  return vals.some((v) =>
    typeof v === "string"
      ? v.toLowerCase() === "true" || v === "on" || v === "1"
      : v === true
  );
}

async function getColumns(supabase: any, table: string): Promise<string[]> {
  try {
    const { data, error } = await supabase.from(table).select("*").limit(1);
    if (error) {
      if (DEBUG_RETRIEVAL && !seenRetrievalWarns.has(error.message)) {
        console.warn(`[columns] ${table}: ${error.message}`);
        seenRetrievalWarns.add(error.message);
      }
      return [];
    }
    const row = Array.isArray(data) ? data[0] : data;
    if (!row) return [];
    return Object.keys(row);
  } catch (e: any) {
    const msg = `[columns] ${table}: ${e?.message ?? e}`;
    if (DEBUG_RETRIEVAL && !seenRetrievalWarns.has(msg)) {
      console.warn(msg);
      seenRetrievalWarns.add(msg);
    }
    return [];
  }
}

async function safe(q: any) {
  try {
    const { data, error } = await q;
    if (error) {
      if (DEBUG_RETRIEVAL && !seenRetrievalWarns.has(error.message)) {
        console.warn(`[retrieval] error: ${error.message}`);
        seenRetrievalWarns.add(error.message);
      }
      return [];
    }
    return data ?? [];
  } catch (e: any) {
    const msg = `[retrieval] unexpected: ${e?.message ?? e}`;
    if (DEBUG_RETRIEVAL && !seenRetrievalWarns.has(msg)) {
      console.warn(msg);
      seenRetrievalWarns.add(msg);
    }
    return [];
  }
}

/** Minimal, defensiv retrieval uden hårde antagelser om kolonnenavne */
async function getChunks(
  supabase: any,
  opts: { ownerId: string; studySetId?: string | null; includeBackground?: boolean; topK?: number }
) {
  const { ownerId, studySetId, includeBackground = false, topK = 12 } = opts;

  const docCols = await getColumns(supabase, "doc_chunks");
  const textCandidates = ["text", "content", "chunk", "chunk_text", "raw_text", "body", "page_text", "pageContent"];
  const textKey = textCandidates.find((k) => docCols.includes(k));

  const wantedBase = ["id", "source_title", "source_url", "source_type"];
  const wanted = wantedBase.filter((k) => docCols.includes(k));

  const selectArr = textKey ? ["id", textKey, ...wanted.filter((k) => k !== "id")] : wanted.length ? wanted : ["id"];
  const selectStr = selectArr.join(",");

  let base = supabase.from("doc_chunks").select(selectStr).limit(topK);
  if (docCols.includes("owner_id")) base = base.eq("owner_id", ownerId);
  if (studySetId && docCols.includes("study_set_id")) base = base.eq("study_set_id", studySetId);
  const userChunks = await safe(base);

  let bgChunks: any[] = [];
  if (includeBackground) {
    let bgQ = supabase.from("doc_chunks").select(selectStr).limit(Math.max(4, Math.floor(topK / 2)));
    if (docCols.includes("source_type")) bgQ = bgQ.eq("source_type", "verified");
    bgChunks = await safe(bgQ);
  }

  const combined: any[] = [...userChunks, ...bgChunks].slice(0, topK);
  const text = textKey ? combined.map((c) => c?.[textKey] ?? "").join("\n\n---\n\n") : "";
  const citations = combined
    .map((c) => ({ id: c?.id, title: c?.source_title, url: c?.source_url, type: c?.source_type }))
    .filter((x) => x.id);

  return { text, citations, textKey };
}

/* Stub – byt til dit rigtige LLM-kald */
async function callModelWithContext(input: { question: string; answer: string; contextText: string }) {
  return {
    score: 20,
    feedback: input.contextText
      ? "Evaluering gennemført. Der blev fundet baggrundstekst."
      : "Evaluering gennemført (uden baggrund).",
  };
}

/* --------- route --------- */

export async function POST(req: Request) {
  try {
    const body = await req.json();
    const includeBackground: boolean = wantsReferencesFromBody(body);
    const studySetId: string | null = body.studySetId ?? null;
    const question: string = String(body.question ?? "");
    const answer: string = String(body.answer ?? "");

    const cookieStore = await nextCookies();
    const supabase = createServerClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
      {
        cookies: {
          get(name: string) {
            return cookieStore.get(name)?.value;
          },
          set() {},
          remove() {},
        },
      }
    );

    const {
      data: { user },
      error: userErr,
    } = await supabase.auth.getUser();
    if (userErr) {
      console.warn("[evaluate] getUser error:", (userErr as any)?.message ?? String(userErr));
      return NextResponse.json({ error: "unauthorized" }, { status: 401 });
    }
    if (!user) {
      return NextResponse.json({ error: "unauthorized" }, { status: 401 });
    }

    const retrieval = await getChunks(supabase, {
      ownerId: user.id,
      studySetId,
      includeBackground,
      topK: 12,
    });

    const hasVerified =
      Array.isArray(retrieval.citations) &&
      retrieval.citations.some((c: any) => (c?.type ?? c?.source_type) === "verified");

    const bgFound = !!includeBackground && (hasVerified || (retrieval.citations?.length ?? 0) > 0);

    const llmAnswer = await callModelWithContext({
      question,
      answer,
      contextText: retrieval.text,
    });

    // Insert kun kolonner der findes
    const examCols = await getColumns(supabase, "exam_sessions");
    const payload: any = { owner_id: user.id, user_id: user.id };
    if (examCols.includes("question")) payload.question = question;
    if (examCols.includes("answer")) payload.answer = answer;
    if (examCols.includes("score")) payload.score = llmAnswer.score ?? null;
    if (examCols.includes("feedback")) payload.feedback = llmAnswer.feedback ?? null;
    if (examCols.includes("model")) payload.model = "gpt-4o-mini";

    const metaObj = {
      includeBackground,
      bgRequested: includeBackground,
      studySetId,
      bgFound,
      citations: retrieval.citations,
      textKey: retrieval.textKey,
    };
    if (examCols.includes("meta")) payload.meta = metaObj;
    else if (examCols.includes("metadata")) payload.metadata = metaObj;

    const { data, error } = await supabase.from("exam_sessions").insert(payload).select("id").single();
    if (error) {
      console.error("[evaluate] insert error:", error.message, "payload keys:", Object.keys(payload));
      return NextResponse.json({ error: error.message }, { status: 500 });
    }

    return NextResponse.json({
      id: data!.id,
      score: llmAnswer.score,
      feedback: llmAnswer.feedback,
      meta: metaObj,
    });
  } catch (e: any) {
    console.error("[evaluate] fatal:", e?.stack || e?.message || e);
    return NextResponse.json({ error: e?.message || "server error" }, { status: 500 });
  }
}
